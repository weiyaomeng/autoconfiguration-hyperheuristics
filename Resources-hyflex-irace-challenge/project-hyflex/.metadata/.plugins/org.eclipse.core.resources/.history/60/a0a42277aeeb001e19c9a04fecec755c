package examples.cf;


/*
 * This class implements a simplified choice function hyper-heuristics for the purpose of the NATCOR2024 @UoN
 * The hyper-heuristic operates on heuristics of type MUTATION, LOCAL_SEARCH, RUIN_RECREATE and uses a simple 'All Moves' acceptance criteria.
 * For each of these heuristics, parameters IOM and DOS are applied.
 * 
 * The simplified version of the modified choice function is:
 * F_t(h_j) = phi_t * f1(h_j) + (1-phi) * f3(h_j)
 * @param F_t: the schore of the heuristic h_j at iteration t.
 * @param f1: a function to score the h_j based on improvement and time taken from its previous application.
 * @param f3: a function to score the h_j based on the time since h_j was last chosen
 * @param phi: if the candidate solution quality was improved, phi = 0.99; else, phi is updated as phi_t = max(0.01, phi_{t-1}-0.01)
 * 
 * f1(h_j) = I(h_j) / T(h_j)
 * @param I: the change in solution quality as a result of applying h_j
 * @param T: the time taken in seconds to apply the h_j the last time it was applied
 * 
 * f3(h_j) = the time in seconds since the h_j was last chosen
 * 
 * @author Weiyao Meng
 * @date 2024.03.26
 */

public class SimplifiedChoiceFunction {

	private Heuristic[] heuristics;

	private double phi;

	public SimplifiedChoiceFunction(Heuristic[] heuristics) {

		this.heuristics = heuristics;
		this.phi = 0.99;
	}

	/**
	 *
	 * @param heuristic
	 * @param timeApplied Current time in nanoseconds.
	 * @param timeTaken Time taken to apply <code>heuristic</code> in nanoseconds.
	 * @param current Objective value of the current solution, f(s_i).
	 * @param candidate Objective value of the candidate solution f(s'_i).
	 */
	public void updateHeuristicData(Heuristic heuristic, long timeApplied, long timeTaken, double current, double candidate) {
		
		
		// timeLastApplied
		heuristic.getData().setTimeLastApplied(timeApplied);
		
		// previousApplicationDuration
		heuristic.getData().setPreviousApplicationDuration(timeTaken);
		
		// F_delta
		heuristic.getData().setF_delta(current-candidate);
		// if improvement - f_delta is negative
		
		this.updatePhi(current, candidate);
		
	}

	public Heuristic selectHeuristicToApply() {
		
		Heuristic selectedHeuristic = null;
		
		double bestScore = -Double.MAX_VALUE;
		long currentTime = System.nanoTime();
		for (Heuristic heuristic : heuristics) {
//			System.out.print("Score of "+heuristic.getHeuristicId()+" is:");
            double score = this.calculateScore(heuristic, currentTime);
            if (score > bestScore) {
                bestScore = score;
                selectedHeuristic = heuristic;
            }
//            System.out.println(" Score: "+score);
        }
		
		return selectedHeuristic;
		
	}
	
	public double calculateScore(Heuristic h, long currentTime) {
		
		// f1 = -f_delta/timeTaken
		double I = h.getData().getF_delta();
		double T = (h.getData().getPreviousApplicationDuration()/1_000_000_000)+1;
		double f1 = I/T;
		
		// f3 = the time in seconds since the h was last chosen by scf
		double f3 = (currentTime - h.getData().getTimeLastApplied())/ 1_000_000_000;
		
//		System.out.print("f1 score: "+f1+" f3 score: "+f3);
		
		// F = phi * f1 + (1-phi) * f3
		return this.phi*f1+(1-phi)*f3;
		
	}

	
	public void updatePhi(double current, double candidate) {
		if(current>candidate) {
			this.phi = 0.99;
		}else {
			this.phi -= 0.01;
			if(this.phi<=0.01) {
				this.phi = 0.01;
			}
		}
	}
	

}
