package examples.rn;


import AbstractClasses.HyperHeuristic;
import AbstractClasses.ProblemDomain;
import examples.scf.Heuristic;
import examples.scf.HeuristicConfiguration;

/**
 * This class presents the ExampleHyperHeuristic1 that allows manually specified arguments.
 * Same as the ExampleHyperHeuristic1, it implements a random heuristic selection method and a "All_Move" acceptance criteria.
 * It operates on heuristics of type MUTATION, LOCAL_SEARCH, RUIN_RECREATE.
 * For each of these heuristics, parameters IOM and DOS are applied.
 * 
 * @author Weiyao Meng (weiyao.meng2@nottingham.ac.uk)
 * @date 2024.03.26
 */

public class RN extends HyperHeuristic {
	

	private Heuristic[] heuristics;
	
	// Default values for DOS and IOM parameters
	double[] dosValues = {0.2, 0.2, 0.2}, iomValues = {0.2, 0.2, 0.2}; 

	public RN(long seed) {
		super(seed);
	}
	
	/**
     * Constructs a new RN hyper-heuristic with the given seed and custom DOS/IOM values.
     * 
     * @param seed the seed value for random number generation
     * @param dosValue an array of custom DOS values for heuristics
     * @param iomValue an array of custom IOM values for heuristics
     */
	
	public RN(long seed, double[] dosValue, double[] iomValue){
		super(seed);
		this.dosValues = dosValue;
		this.iomValues = iomValue;
	}
	
	/**
	 * This method defines the strategy of the hyper-heuristic
	 * @param problem the problem domain to be solved
	 */
	public void solve(ProblemDomain problem) {

		// Record the number of low level heuristics, as this changes depending on the problem domain
		int number_of_heuristics = problem.getNumberOfHeuristics();
		
		// Create heuristics array with customised configurations
		Heuristic[] heuristics = createHeuristics(problem, dosValues, iomValues);
		
		
//		heuristics = new Heuristic[number_of_heuristics]; // Initialise the heuristics array
//        heuristics = createHeuristics(problem, dosValues, iomValues);

		//initialise the variable which keeps track of the current objective function value
		double current_obj_function_value = Double.POSITIVE_INFINITY;

		//initialise the solution at index 0 in the solution memory array
		problem.initialiseSolution(0);

		//the main loop of any hyper-heuristic, which checks if the time limit has been reached
		while (!hasTimeExpired()) {

			//this hyper-heuristic chooses a random low level heuristic to apply
			int heuristic_to_apply = rng.nextInt(number_of_heuristics);
			
			// set the dos and iom based on the selected LLH
			Heuristic h = heuristics[heuristic_to_apply];
			problem.setDepthOfSearch(h.getConfiguration().getDos());
			problem.setIntensityOfMutation(h.getConfiguration().getIom());

			//apply the chosen heuristic to the solution at index 0 in the memory
			//the new solution is then stored at index 1 of the solution memory while we decide whether to accept it
			double new_obj_function_value = problem.applyHeuristic(heuristic_to_apply, 0, 1);
			
//			System.out.println("ID: "+heuristic_to_apply+" IOM: "+problem.getIntensityOfMutation()+" DOS: "+problem.getDepthOfSearch());
//			System.out.println(current_obj_function_value+"  "+new_obj_function_value+"  "+problem.getBestSolutionValue());
					
			//calculate the change in fitness from the current solution to the new solution
			double delta = current_obj_function_value - new_obj_function_value;

			//all of the problem domains are implemented as minimisation problems. A lower fitness means a better solution.
			if (delta > 0) {
				//if there is an improvement then we 'accept' the solution by copying the new solution into memory index 0
				problem.copySolution(1, 0);
				//we also set the current objective function value to the new function value, as the new solution is now the current solution
				current_obj_function_value = new_obj_function_value;
			} else {
				//if there is not an improvement in solution quality then we accept the solution with a 50% probability
				if (rng.nextBoolean()) {
					//the process for 'accepting' a solution is the same as above
					problem.copySolution(1, 0);
					current_obj_function_value = new_obj_function_value;
				}
			}
			//one iteration has been completed, so we return to the start of the main loop and check if the time has expired 
		}
	}
	
	/**
	 * this method must be implemented, to provide a different name for each hyper-heuristic
	 * @return a string representing the name of the hyper-heuristic
	 */
	public String toString() {
		return "Example Hyper Heuristic One";
	}
	
	/*
	 * Method to create an array of low-level heuristics with different configurations
	 * It first initialise LLHs with default configurations.
	 * Then, for heuristics that use DOS and IOM values, 
	 * it sets the DOS/IOM values according to the provided dosValues/iomValues array.
	 */
	private Heuristic[] createHeuristics(ProblemDomain problem, double[] dosValues, double[] iomValues) {
			
		// Initialise array to store heuristic objects
		int numHeuristics = problem.getNumberOfHeuristics();
		Heuristic[] heuristics = new Heuristic[numHeuristics];
		
		// Create heuristic objects with default configurations
    	for (int i = 0; i < numHeuristics; i++) {
            HeuristicConfiguration configuration = new HeuristicConfiguration(0.2, 0.2);
            heuristics[i] = new Heuristic(configuration, i, startTimeNano); 
        }
        
    	// Retrieve heuristics that use DOS and IOM parameters
        int[] dosHeuristics = problem.getHeuristicsThatUseDepthOfSearch();
        int[] iomHeuristics = problem.getHeuristicsThatUseIntensityOfMutation();
 
        // Apply custom DOS values to corresponding heuristic IDs
        for (int i = 0; i < dosHeuristics.length; i++) {
            int id = dosHeuristics[i];
            double value = dosValues[i];
            heuristics[id].getConfiguration().setDos(value);
        }
        
        // Apply custom IOM values to corresponding heuristic IDs
        for (int i = 0; i < iomHeuristics.length; i++) {
            int id = iomHeuristics[i];
            double value = iomValues[i];
            heuristics[id].getConfiguration().setIom(value); 
        }

        return heuristics; //return the array heuristics containing all the configured heuristic objects.
    }

    private Heuristic[] createHeuristics(ProblemDomain problem, double[] dosValues, double[] iomValues) {
    	
    	int numHeuristics = problem.getNumberOfHeuristics();
    	for (int i = 0; i < numHeuristics; i++) {
            HeuristicConfiguration configuration = new HeuristicConfiguration(0.2, 0.2);
            heuristics[i] = new Heuristic(configuration, i); 
        }
        
        int[] dosHeuristics = problem.getHeuristicsThatUseDepthOfSearch();
        int[] iomHeuristics = problem.getHeuristicsThatUseIntensityOfMutation();
 
        // Apply HeuristicConfiguration with dos values to corresponding heuristic IDs
        for (int i = 0; i < dosHeuristics.length; i++) {
            int id = dosHeuristics[i];
            double value = dosValues[i];
            HeuristicConfiguration configuration = new HeuristicConfiguration(0.2, value);
            heuristics[id] = new Heuristic(configuration, id); 
        }
        
        for (int i = 0; i < iomHeuristics.length; i++) {
            int id = iomHeuristics[i];
            double value = iomValues[i];
            HeuristicConfiguration configuration = new HeuristicConfiguration(value, 0.2);
            heuristics[id] = new Heuristic(configuration, id); 
        }

        return heuristics; //return the array heuristics containing all the configured heuristic objects.
    }
	
}
